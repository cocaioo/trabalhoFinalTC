\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[brazilian]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{textcomp}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{colortbl}
\usepackage{tikz}
\usepackage{listings}
\usepackage{tcolorbox}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}

\usetikzlibrary{automata,positioning,arrows.meta,shapes,calc}

\geometry{
    a4paper,
    left=3cm,
    right=2cm,
    top=3cm,
    bottom=2cm
}

\definecolor{pastelblue}{RGB}{174,198,207}
\definecolor{pastelgreen}{RGB}{189,215,180}
\definecolor{pastelyellow}{RGB}{255,239,186}
\definecolor{pastelrose}{RGB}{244,202,205}
\definecolor{pastellavender}{RGB}{209,196,233}
\definecolor{pastelorange}{RGB}{255,213,173}
\definecolor{darkblue}{RGB}{41,98,255}
\definecolor{darkgreen}{RGB}{34,139,34}
\definecolor{codebg}{RGB}{248,248,248}
\definecolor{commentgreen}{RGB}{82,139,139}

\tcbuselibrary{listings,skins,breakable}

\newtcolorbox{infobox}[1]{
    colback=pastelblue!30,
    colframe=pastelblue!80!black,
    fonttitle=\bfseries,
    title=#1,
    arc=3mm,
    boxrule=1pt,
    left=5pt,right=5pt,top=5pt,bottom=5pt
}

\newtcolorbox{warningbox}[1]{
    colback=pastelyellow!30,
    colframe=pastelyellow!80!black,
    fonttitle=\bfseries,
    title=#1,
    arc=3mm,
    boxrule=1pt,
    left=5pt,right=5pt,top=5pt,bottom=5pt
}

\newtcolorbox{successbox}[1]{
    colback=pastelgreen!30,
    colframe=pastelgreen!80!black,
    fonttitle=\bfseries,
    title=#1,
    arc=3mm,
    boxrule=1pt,
    left=5pt,right=5pt,top=5pt,bottom=5pt
}

\lstdefinestyle{pythonstyle}{
    language=Python,
    backgroundcolor=\color{codebg},
    commentstyle=\color{commentgreen}\itshape,
    keywordstyle=\color{darkblue}\bfseries,
    stringstyle=\color{pastelrose!80!black},
    basicstyle=\ttfamily\small,
    breaklines=true,
    breakatwhitespace=false,
    numbers=left,
    numberstyle=\tiny\color{gray},
    numbersep=8pt,
    showstringspaces=false,
    tabsize=4,
    frame=single,
    rulecolor=\color{pastelblue!60!black},
    xleftmargin=15pt,
    xrightmargin=5pt,
    framexleftmargin=10pt
}

\lstdefinestyle{bashstyle}{
    language=bash,
    backgroundcolor=\color{codebg},
    basicstyle=\ttfamily\small,
    breaklines=true,
    numbers=none,
    frame=single,
    rulecolor=\color{pastelgreen!60!black},
    xleftmargin=10pt,
    xrightmargin=5pt
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\small Trabalho Final - Teoria da Computação}
\fancyhead[R]{\small UFPI - 2025}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\hypersetup{
    colorlinks=true,
    linkcolor=darkblue,
    urlcolor=darkblue,
    citecolor=darkblue,
    pdfborder={0 0 0}
}

\title{}
\author{}
\date{}

\begin{document}

\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    {\LARGE \textbf{Trabalho Final de Teoria da Computação}}\\[1.5cm]
    
    {\Large \textbf{Tema 1: Conversão de Expressão Regular para AFN-$\varepsilon$\\[0.4cm]
    e Reconhecimento de Cadeias}}\\[3cm]
    
    {\large
    \textbf{Autores:}\\[0.5cm]
    Caio Victor Ferreira do Nascimento\\
    Samuel Furtado Fortes
    }\\[3cm]
    
    {\normalsize
    Universidade Federal do Piauí (UFPI)\\[0.3cm]
    Curso: Ciência da Computação\\[0.3cm]
    Disciplina: Teoria da Computação\\[0.3cm]
    Professor: Carlos André Batista de Carvalho
    }\\[2cm]
    
    \vfill
    
    {\normalsize \today}
\end{titlepage}

\thispagestyle{empty}

\begin{abstract}
\noindent Este trabalho apresenta a implementação de um conversor de Expressões Regulares (ER) para Autômatos Finitos Não-determinísticos com $\varepsilon$-transições (AFN-$\varepsilon$) utilizando o Algoritmo de Thompson. 

\vspace{0.3cm}
\noindent O sistema desenvolvido em Python inclui módulos para conversão, reconhecimento de cadeias e visualização gráfica dos autômatos gerados. Além da implementação base, foi desenvolvida uma suíte completa de testes automatizados e duas interfaces de usuário: uma versão em terminal e outra com interface gráfica utilizando Tkinter. 

\vspace{0.3cm}
\noindent Os resultados demonstram a corretude da implementação através da validação de 50 casos de teste, confirmando o funcionamento adequado do algoritmo em diversas expressões regulares.
\end{abstract}

\tableofcontents
\newpage

\section{Introdução}

\noindent A teoria dos autômatos e linguagens formais constitui um dos pilares fundamentais da Ciência da Computação, fornecendo a base teórica para análise léxica, casamento de padrões e validação de entradas. Este trabalho implementa um sistema completo para conversão de Expressões Regulares em Autômatos Finitos Não-determinísticos com $\varepsilon$-transições.

\subsection{Objetivos}

\noindent Os principais objetivos deste trabalho são:

\vspace{0.3cm}
\begin{itemize}[leftmargin=1.5cm, itemsep=0.3cm]
    \item Implementar o Algoritmo de Thompson para conversão ER $\rightarrow$ AFN-$\varepsilon$
    
    \item Desenvolver um reconhecedor de cadeias utilizando o autômato gerado
    
    \item Criar ferramentas de visualização gráfica dos autômatos
    
    \item Validar a implementação através de testes automatizados
    
    \item Fornecer interfaces amigáveis para interação com o usuário
\end{itemize}

\subsection{Estrutura do Documento}

\noindent Este relatório está organizado da seguinte forma: a Seção 2 apresenta os fundamentos teóricos; a Seção 3 descreve a implementação do sistema; a Seção 4 demonstra como executar o código; a Seção 5 explica o processo de construção dos autômatos; a Seção 6 apresenta os resultados dos testes; e a Seção 7 conclui o trabalho.

\newpage
\section{Fundamentos Teóricos}

\subsection{Expressões Regulares}

Uma \textbf{Expressão Regular (ER)} é uma notação formal para descrever linguagens regulares. As operações básicas são:

\begin{infobox}{Operações de Expressões Regulares}
\begin{itemize}[leftmargin=*]
    \item \textbf{Símbolo}: $a$ representa o símbolo literal
    \item \textbf{União}: $a \mid b$ aceita $a$ ou $b$
    \item \textbf{Concatenação}: $ab$ aceita $a$ seguido de $b$
    \item \textbf{Fechamento de Kleene}: $a^*$ aceita zero ou mais $a$
    \item \textbf{Parênteses}: $(a \mid b)$ agrupa expressões
\end{itemize}
\end{infobox}

\subsection{Autômatos Finitos Não-determinísticos}

Um \textbf{AFN-$\varepsilon$} é uma quíntupla $M = (Q, \Sigma, \delta, q_0, F)$ onde:

\begin{itemize}[leftmargin=*]
    \item $Q$ é um conjunto finito de estados
    \item $\Sigma$ é o alfabeto de entrada
    \item $\delta: Q \times (\Sigma \cup \{\varepsilon\}) \rightarrow 2^Q$ é a função de transição
    \item $q_0 \in Q$ é o estado inicial
    \item $F \subseteq Q$ é o conjunto de estados finais
\end{itemize}

\subsection{Algoritmo de Thompson}

\noindent O Algoritmo de Thompson constrói AFN-$\varepsilon$ de forma composicional, aplicando regras específicas para cada operação da expressão regular. O algoritmo funciona de forma recursiva, criando sub-autômatos para cada componente da expressão e combinando-os usando $\varepsilon$-transições.

\subsubsection{Regras de Construção}

\begin{infobox}{Construção para Símbolo Individual}
\textbf{Regra:} Para um símbolo $a$, cria-se um autômato com:
\begin{itemize}[leftmargin=*]
    \item Um estado inicial $q_0$
    \item Um estado final $q_1$
    \item Uma transição de $q_0$ para $q_1$ com o símbolo $a$
\end{itemize}
Este é o caso base do algoritmo.
\end{infobox}

\vspace{0.3cm}

\begin{infobox}{Construção para União ($r_1 \mid r_2$)}
\textbf{Regra:} Dados dois AFN-$\varepsilon$ para $r_1$ e $r_2$, cria-se:
\begin{itemize}[leftmargin=*]
    \item Um novo estado inicial $q_0$
    \item Um novo estado final $q_f$
    \item $\varepsilon$-transições de $q_0$ para os estados iniciais de $r_1$ e $r_2$
    \item $\varepsilon$-transições dos estados finais de $r_1$ e $r_2$ para $q_f$
\end{itemize}
Isso permite que o autômato escolha não-deterministicamente entre $r_1$ ou $r_2$.
\end{infobox}

\vspace{0.3cm}

\begin{infobox}{Construção para Concatenação ($r_1 r_2$)}
\textbf{Regra:} Dados dois AFN-$\varepsilon$ para $r_1$ e $r_2$, cria-se:
\begin{itemize}[leftmargin=*]
    \item Uma $\varepsilon$-transição do estado final de $r_1$ para o estado inicial de $r_2$
    \item O estado inicial de $r_1$ torna-se o estado inicial do novo autômato
    \item O estado final de $r_2$ torna-se o estado final do novo autômato
\end{itemize}
Isso força o processamento de $r_1$ antes de $r_2$.
\end{infobox}

\vspace{0.3cm}

\begin{infobox}{Construção para Fechamento de Kleene ($r^*$)}
\textbf{Regra:} Dado um AFN-$\varepsilon$ para $r$, cria-se:
\begin{itemize}[leftmargin=*]
    \item Um novo estado inicial $q_0$ e um novo estado final $q_f$
    \item Uma $\varepsilon$-transição de $q_0$ para o estado inicial de $r$
    \item Uma $\varepsilon$-transição do estado final de $r$ para $q_f$
    \item Uma $\varepsilon$-transição de $q_0$ para $q_f$ (para aceitar a cadeia vazia)
    \item Uma $\varepsilon$-transição do estado final de $r$ para seu estado inicial (para repetição)
\end{itemize}
Isso permite zero ou mais repetições de $r$.
\end{infobox}

\newpage
\section{Implementação do Sistema}

\noindent O sistema foi implementado em Python 3 e organizado em módulos independentes, facilitando manutenção e extensibilidade. A implementação segue o Algoritmo de Thompson, construindo AFN-$\varepsilon$ de forma composicional.

\subsection{Módulos Principais}

\subsubsection{Módulo: afn.py}

Define as estruturas básicas de estados e autômatos:

\begin{lstlisting}[style=pythonstyle, caption={Classe Estado}]
class Estado:
    contador = 0

    def __init__(self):
        self.id = Estado.contador
        Estado.contador += 1
        self.transicoes = {}
        self.eh_final = False

    def adicionar_transicao(self, simbolo, estado_destino):
        if simbolo not in self.transicoes:
            self.transicoes[simbolo] = []
        self.transicoes[simbolo].append(estado_destino)
\end{lstlisting}

\begin{infobox}{Características da Classe Estado}
\begin{itemize}[leftmargin=*]
    \item \textbf{ID único}: Contador global garante identificação única
    \item \textbf{Transições}: Dicionário permite múltiplas transições por símbolo
    \item \textbf{Estado final}: Flag booleana para marcação
\end{itemize}
\end{infobox}

\subsubsection{Módulo: conversor.py}

Implementa o Algoritmo de Thompson através de parsing recursivo:

\begin{lstlisting}[style=pythonstyle, caption={Conversão de símbolo básico}]
def _simbolo(self, simbolo):
    inicial = Estado()
    final = Estado()
    inicial.adicionar_transicao(simbolo, final)
    return AFN(inicial, final)
\end{lstlisting}

\begin{lstlisting}[style=pythonstyle, caption={Operação de união}]
def _uniao(self, afn1, afn2):
    novo_inicial = Estado()
    novo_final = Estado()
    
    novo_inicial.adicionar_transicao('ε', afn1.estado_inicial)
    novo_inicial.adicionar_transicao('ε', afn2.estado_inicial)
    
    afn1.estado_final.eh_final = False
    afn2.estado_final.eh_final = False
    
    afn1.estado_final.adicionar_transicao('ε', novo_final)
    afn2.estado_final.adicionar_transicao('ε', novo_final)
    
    return AFN(novo_inicial, novo_final)
\end{lstlisting}

\subsubsection{Módulo: reconhecedor.py}

Implementa reconhecimento através de $\varepsilon$-fecho:

\begin{lstlisting}[style=pythonstyle, caption={Cálculo do $\varepsilon$-fecho}]
def _epsilon_fecho(self, estados):
    fecho = set(estados)
    pilha = list(estados)
    
    while pilha:
        estado = pilha.pop()
        
        if 'ε' in estado.transicoes:
            for destino in estado.transicoes['ε']:
                if destino not in fecho:
                    fecho.add(destino)
                    pilha.append(destino)
    
    return fecho
\end{lstlisting}

\newpage
\section{Guia de Execução}

Esta seção apresenta instruções detalhadas para executar o sistema implementado.

\subsection{Requisitos do Sistema}

\begin{warningbox}{Pré-requisitos}
\begin{itemize}[leftmargin=*]
    \item \textbf{Python}: Versão 3.8 ou superior
    \item \textbf{Bibliotecas}: matplotlib, tkinter (geralmente incluído no Python)
    \item \textbf{Sistema Operacional}: Windows, Linux ou macOS
\end{itemize}
\end{warningbox}

\subsection{Instalação das Dependências}

Para a interface gráfica, instale o matplotlib:

\begin{lstlisting}[style=bashstyle, caption={Instalação via pip}]
pip install matplotlib
\end{lstlisting}

\subsection{Execução do Programa}

\noindent Para executar o programa, basta rodar o seguinte comando no terminal:

\begin{lstlisting}[style=bashstyle, caption={Executar o programa}]
python main_terminal.py
\end{lstlisting}

\begin{figure}[H]
\centering
\begin{tcolorbox}[colback=codebg, colframe=pastelgreen!60!black, width=0.95\textwidth]
\small\ttfamily
============================================================\\
CONVERSOR DE EXPRESSÃO REGULAR PARA AFN-ε\\
Trabalho Final - Teoria da Computação\\
============================================================\\
\\
Notação suportada:\\
\quad • Concatenação: ab (símbolos adjacentes)\\
\quad • União: a|b\\
\quad • Fechamento de Kleene: a*\\
\quad • Parênteses: (a|b)*\\
\quad • Símbolos: letras, dígitos e caracteres especiais\\
\\
------------------------------------------------------------\\
Digite a expressão regular: \colorbox{pastelyellow!40}{(a|b)*}\\
\\
Convertendo ER '(a|b)*' para AFN-ε...\\
\end{tcolorbox}
\caption{Exemplo de execução no terminal}
\label{fig:terminal}
\end{figure}

\vspace{0.5cm}
\noindent O sistema também possui uma interface gráfica que pode ser executada com:

\begin{lstlisting}[style=bashstyle, caption={Executar interface gráfica (opcional)}]
python interface.py
\end{lstlisting}

\subsection{Execução dos Testes}

O sistema inclui 50 testes automatizados:

\begin{lstlisting}[style=bashstyle, caption={Executar testes com pytest}]
python -m pytest test_afn.py -v
\end{lstlisting}

Ou utilizando unittest:

\begin{lstlisting}[style=bashstyle, caption={Executar testes com unittest}]
python -m unittest test_afn.py -v
\end{lstlisting}

\newpage
\section{Processo de Construção de Autômatos}

\noindent Esta seção detalha como os autômatos são construídos pelo algoritmo implementado através de exemplos práticos.

\subsection{Exemplo 1: Expressão Simples $(a|b)$}

\noindent A construção da expressão $(a|b)$ acontece em três etapas principais:

\vspace{0.3cm}
\begin{successbox}{Passo 1: Construir autômato para $a$}
Cria-se um AFN simples com dois estados:
\begin{itemize}[leftmargin=*]
    \item Estado inicial $q_0$
    \item Estado final $q_1$
    \item Transição: $q_0 \xrightarrow{a} q_1$
\end{itemize}
\end{successbox}

\vspace{0.3cm}
\begin{successbox}{Passo 2: Construir autômato para $b$}
Similarmente, cria-se outro AFN com dois estados:
\begin{itemize}[leftmargin=*]
    \item Estado inicial $q_2$
    \item Estado final $q_3$
    \item Transição: $q_2 \xrightarrow{b} q_3$
\end{itemize}
\end{successbox}

\vspace{0.3cm}
\begin{successbox}{Passo 3: Aplicar operação de união}
Combina-se os dois autômatos criando:
\begin{itemize}[leftmargin=*]
    \item Novo estado inicial $q_4$ com $\varepsilon$-transições para $q_0$ e $q_2$
    \item Novo estado final $q_5$ recebendo $\varepsilon$-transições de $q_1$ e $q_3$
    \item Total de 6 estados e 6 transições (2 com símbolos, 4 com $\varepsilon$)
\end{itemize}
\end{successbox}

\subsection{Exemplo 2: Fechamento de Kleene $(a|b)^*$}

\noindent Aplicando o fechamento de Kleene sobre o AFN de $(a|b)$ construído anteriormente:

\vspace{0.3cm}
\begin{infobox}{Estrutura Resultante}
O autômato resultante possui:
\begin{itemize}[leftmargin=*]
    \item \textbf{8 estados}: $q_0$ a $q_7$, onde $q_6$ é o inicial e $q_7$ é o final
    \item \textbf{$\varepsilon$-transição de bypass}: $q_6 \xrightarrow{\varepsilon} q_7$ permite aceitar a cadeia vazia
    \item \textbf{$\varepsilon$-transição de loop}: $q_5 \xrightarrow{\varepsilon} q_4$ permite repetições
    \item \textbf{Transições com símbolos}: Mantém as transições $a$ e $b$ do AFN original
\end{itemize}
\end{infobox}

\vspace{0.3cm}
\begin{warningbox}{Características do AFN-$\varepsilon$ para $(a|b)^*$}
\begin{itemize}[leftmargin=*]
    \item Aceita a cadeia vazia ($\varepsilon$) através do caminho direto $q_6 \to q_7$
    \item Aceita qualquer sequência de $a$'s e $b$'s através das repetições
    \item Exemplos aceitos: $\varepsilon$, "a", "b", "aa", "ab", "ba", "bb", "aba", "abba", etc.
\end{itemize}
\end{warningbox}

\subsection{Exemplo 3: Concatenação $ab$}

\noindent Para a expressão $ab$, o processo é:

\vspace{0.3cm}
\begin{successbox}{Construção da Concatenação}
\begin{enumerate}[leftmargin=*]
    \item Cria-se AFN para $a$: estados $q_0$ e $q_1$ com transição $q_0 \xrightarrow{a} q_1$
    \item Cria-se AFN para $b$: estados $q_2$ e $q_3$ com transição $q_2 \xrightarrow{b} q_3$
    \item Conecta-se através de $\varepsilon$-transição: $q_1 \xrightarrow{\varepsilon} q_2$
    \item Estado inicial: $q_0$ | Estado final: $q_3$
\end{enumerate}
\end{successbox}

\vspace{0.3cm}
\noindent \textbf{Resultado:} O autômato aceita apenas a cadeia "ab", processando primeiro o símbolo $a$ e depois o símbolo $b$.

\subsection{Fluxo de Processamento}

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    proc/.style={rectangle, draw, fill=pastelblue!40, text width=3.5cm, 
                 text centered, rounded corners, minimum height=1cm, thick},
    decision/.style={diamond, draw, fill=pastelyellow!40, text width=2cm,
                     text centered, aspect=2, thick},
    arrow/.style={->, >=Stealth, thick}
]
    \node[proc] (input) at (0,0) {Entrada: Expressão Regular};
    \node[proc] (parse) at (0,-2) {Parsing Recursivo};
    \node[decision] (check) at (0,-4) {Operador?};
    \node[proc] (symbol) at (-4,-6) {Construir Símbolo};
    \node[proc] (union) at (0,-6) {Aplicar União};
    \node[proc] (concat) at (4,-6) {Aplicar Concat.};
    \node[proc] (kleene) at (0,-8) {Aplicar Kleene};
    \node[proc] (output) at (0,-10) {Retornar AFN-$\varepsilon$};
    
    \draw[arrow] (input) -- (parse);
    \draw[arrow] (parse) -- (check);
    \draw[arrow] (check) -- node[left] {símbolo} (symbol);
    \draw[arrow] (check) -- node[above] {$|$} (union);
    \draw[arrow] (check) -- node[right] {concat} (concat);
    \draw[arrow] (symbol) |- (kleene);
    \draw[arrow] (union) -- (kleene);
    \draw[arrow] (concat) |- (kleene);
    \draw[arrow] (kleene) -- (output);
    
\end{tikzpicture}
\caption{Fluxograma do processo de conversão}
\label{fig:flowchart}
\end{figure}

\newpage
\section{Reconhecimento de Cadeias}

O processo de reconhecimento utiliza o conceito de $\varepsilon$-fecho para processar cadeias.

\subsection{Algoritmo de Reconhecimento}

\begin{infobox}{Etapas do Reconhecimento}
\begin{enumerate}[leftmargin=*]
    \item Calcular $\varepsilon$-FECHO($q_0$) = conjunto inicial de estados
    \item Para cada símbolo $a$ na cadeia:
    \begin{itemize}
        \item Obter estados alcançáveis com $a$
        \item Calcular $\varepsilon$-FECHO desses estados
    \end{itemize}
    \item Verificar se algum estado final foi alcançado
\end{enumerate}
\end{infobox}

\subsection{Exemplo: Reconhecendo "ab" em $(a|b)^*$}

\noindent O reconhecimento da cadeia "ab" no autômato de $(a|b)^*$ segue os seguintes passos:

\vspace{0.3cm}
\begin{table}[H]
\centering
\begin{tabular}{|c|l|p{7cm}|}
\hline
\rowcolor{pastelblue!40}
\textbf{Passo} & \textbf{Símbolo} & \textbf{Estados Atuais} \\
\hline
Inicial & - & $\{q_6, q_4, q_0, q_2, q_7\}$ \\
\hline
\rowcolor{pastelgreen!20}
Após ler 'a' & a & $\{q_1, q_5, q_4, q_0, q_2, q_7\}$ \\
\hline
\rowcolor{pastellavender!20}
Após ler 'b' & b & $\{q_3, q_5, q_4, q_0, q_2, q_7\}$ \\
\hline
\end{tabular}
\caption{Processamento da cadeia "ab"}
\label{tab:recognition}
\end{table}

\vspace{0.3cm}
\begin{successbox}{Resultado}
\textbf{ACEITA} - Estado final $q_7$ foi alcançado no conjunto final de estados.
\end{successbox}

\vspace{0.3cm}
\noindent \textbf{Observação:} Note que após processar cada símbolo, o autômato pode estar em múltiplos estados simultaneamente devido ao não-determinismo e às $\varepsilon$-transições. O $\varepsilon$-fecho é calculado após cada transição para incluir todos os estados alcançáveis sem consumir símbolos.

\newpage
\section{Resultados dos Testes}

Foram implementados 50 testes automatizados cobrindo diferentes aspectos do sistema.

\subsection{Categorias de Testes}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|}
\hline
\rowcolor{pastelblue!40}
\textbf{Categoria} & \textbf{Quantidade} & \textbf{Status} \\
\hline
Estrutura de Estados & 3 & \cellcolor{pastelgreen!40}✓ PASS \\
\hline
Estrutura de AFN & 2 & \cellcolor{pastelgreen!40}✓ PASS \\
\hline
Conversão - Símbolos & 3 & \cellcolor{pastelgreen!40}✓ PASS \\
\hline
Conversão - Concatenação & 2 & \cellcolor{pastelgreen!40}✓ PASS \\
\hline
Conversão - União & 2 & \cellcolor{pastelgreen!40}✓ PASS \\
\hline
Conversão - Kleene & 2 & \cellcolor{pastelgreen!40}✓ PASS \\
\hline
Reconhecimento - Simples & 4 & \cellcolor{pastelgreen!40}✓ PASS \\
\hline
Reconhecimento - União & 3 & \cellcolor{pastelgreen!40}✓ PASS \\
\hline
Reconhecimento - Kleene & 5 & \cellcolor{pastelgreen!40}✓ PASS \\
\hline
Reconhecimento - Complexo & 8 & \cellcolor{pastelgreen!40}✓ PASS \\
\hline
Reconhecimento - Números & 4 & \cellcolor{pastelgreen!40}✓ PASS \\
\hline
Cadeia Vazia & 2 & \cellcolor{pastelgreen!40}✓ PASS \\
\hline
Parênteses & 5 & \cellcolor{pastelgreen!40}✓ PASS \\
\hline
Casos Avançados & 5 & \cellcolor{pastelgreen!40}✓ PASS \\
\hline
\rowcolor{pastelgreen!60}
\textbf{TOTAL} & \textbf{50} & \textbf{✓ 100\% PASS} \\
\hline
\end{tabular}
\caption{Resumo dos resultados dos testes}
\label{tab:tests}
\end{table}

\subsection{Tempo de Execução}

\begin{successbox}{Desempenho}
Todos os 50 testes foram executados em \textbf{0.34 segundos}, demonstrando a eficiência da implementação.
\end{successbox}

\subsection{Casos de Teste Destacados}

\begin{table}[H]
\centering
\small
\begin{tabular}{|l|l|c|}
\hline
\rowcolor{pastelblue!40}
\textbf{ER} & \textbf{Cadeia} & \textbf{Resultado} \\
\hline
$a$ & "a" & \cellcolor{pastelgreen!40}ACEITA \\
\hline
$a$ & "b" & \cellcolor{pastelrose!40}REJEITA \\
\hline
$ab$ & "ab" & \cellcolor{pastelgreen!40}ACEITA \\
\hline
$a|b$ & "a" & \cellcolor{pastelgreen!40}ACEITA \\
\hline
$a|b$ & "b" & \cellcolor{pastelgreen!40}ACEITA \\
\hline
$a^*$ & "" & \cellcolor{pastelgreen!40}ACEITA \\
\hline
$a^*$ & "aaa" & \cellcolor{pastelgreen!40}ACEITA \\
\hline
$(a|b)^*$ & "abba" & \cellcolor{pastelgreen!40}ACEITA \\
\hline
$(a|b)^*$ & "c" & \cellcolor{pastelrose!40}REJEITA \\
\hline
$(aa)^*$ & "aa" & \cellcolor{pastelgreen!40}ACEITA \\
\hline
$(aa)^*$ & "aaa" & \cellcolor{pastelrose!40}REJEITA \\
\hline
$ab|cd$ & "ab" & \cellcolor{pastelgreen!40}ACEITA \\
\hline
$ab|cd$ & "ac" & \cellcolor{pastelrose!40}REJEITA \\
\hline
\end{tabular}
\caption{Exemplos de casos de teste}
\label{tab:testcases}
\end{table}

\newpage
\section{Exemplos de Uso}

Esta seção apresenta exemplos práticos de utilização do sistema.

\subsection{Exemplo Completo: $(0|1)^*$}

\subsubsection{Entrada}

\begin{lstlisting}[style=bashstyle]
Digite a expressão regular: (0|1)*
\end{lstlisting}

\subsubsection{Estrutura do AFN Gerado}

\noindent O autômato gerado para $(0|1)^*$ possui a seguinte estrutura:

\vspace{0.3cm}
\begin{infobox}{Características do AFN para $(0|1)^*$}
\begin{itemize}[leftmargin=*]
    \item \textbf{Total de estados}: 8 estados ($q_0$ a $q_7$)
    \item \textbf{Estado inicial}: $q_0$
    \item \textbf{Estado final}: $q_7$
    \item \textbf{Transições com símbolos}: 
        \begin{itemize}
            \item $q_2 \xrightarrow{0} q_3$ (reconhece o símbolo 0)
            \item $q_4 \xrightarrow{1} q_5$ (reconhece o símbolo 1)
        \end{itemize}
    \item \textbf{$\varepsilon$-transições}: 7 transições vazias que permitem:
        \begin{itemize}
            \item Aceitar a cadeia vazia
            \item Escolher entre 0 ou 1
            \item Repetir a escolha quantas vezes necessário
        \end{itemize}
\end{itemize}
\end{infobox}

\subsubsection{Teste de Cadeias}

\begin{lstlisting}[style=bashstyle]
Cadeia: 101
Processando cadeia: '101'
------------------------------------------------------------
Inicial: {q0, q1, q2, q4, q7}
Apos ler 1 '1': {q5, q6, q1, q2, q4, q7}
Apos ler 2 '0': {q3, q6, q1, q2, q4, q7}
Apos ler 3 '1': {q5, q6, q1, q2, q4, q7}

✓ ACEITA - Estado final q7 alcançado
\end{lstlisting}

\newpage
\section{Conclusão}

Este trabalho apresentou uma implementação completa e funcional de um conversor de Expressões Regulares para AFN-$\varepsilon$ utilizando o Algoritmo de Thompson.

\subsection{Resultados Alcançados}

\begin{itemize}[leftmargin=*]
    \item \textbf{Implementação correta}: 100\% dos testes aprovados (50/50)
    \item \textbf{Modularidade}: Código organizado em módulos independentes
    \item \textbf{Usabilidade}: Duas interfaces (terminal e gráfica)
    \item \textbf{Documentação}: Código limpo e bem estruturado
    \item \textbf{Visualização}: Ferramenta gráfica para análise visual
    \item \textbf{Testes}: Cobertura abrangente de casos de uso
\end{itemize}

\subsection{Aprendizados}

Durante o desenvolvimento deste projeto, consolidamos conhecimentos sobre:

\begin{itemize}[leftmargin=*]
    \item Teoria dos autômatos e linguagens formais
    \item Algoritmo de Thompson para construção de AFN-$\varepsilon$
    \item Técnicas de parsing recursivo descendente
    \item Desenvolvimento de interfaces gráficas em Python
    \item Práticas de testes automatizados
    \item Visualização de estruturas de dados complexas
\end{itemize}

\subsection{Trabalhos Futuros}

Possíveis extensões para este trabalho incluem:

\begin{itemize}[leftmargin=*]
    \item Conversão de AFN-$\varepsilon$ para AFD (Algoritmo de Subconjuntos)
    \item Minimização de autômatos
    \item Suporte a operadores adicionais ($+$, $?$, classes de caracteres)
    \item Geração de código para reconhecedores
    \item Interface web utilizando frameworks como Flask ou Django
    \item Análise de complexidade e otimizações de performance
\end{itemize}

\subsection{Considerações Finais}

A implementação demonstrou ser robusta e eficiente, validada através de extensa bateria de testes. O sistema desenvolvido serve como ferramenta educacional para compreensão prática dos conceitos de Teoria da Computação, além de base sólida para extensões futuras.

O código-fonte está disponível de forma organizada e documentada, facilitando manutenção e evolução do projeto.

\vspace{1cm}

\begin{center}
\rule{0.8\textwidth}{0.5pt}

\vspace{0.5cm}

\textit{Trabalho desenvolvido com dedicação para a disciplina de\\
Teoria da Computação - UFPI - 2025}

\vspace{0.5cm}

\textbf{Caio Victor Ferreira do Nascimento}

\textbf{Samuel Furtado Fortes}
\end{center}

\newpage
\appendix
\section{Código-Fonte Completo}

\subsection{Estrutura de Arquivos}

\begin{lstlisting}[style=bashstyle]
trabalho-final-tc/
├── afn.py                  # Estruturas básicas
├── conversor.py            # Algoritmo de Thompson
├── reconhecedor.py         # Reconhecimento de cadeias
├── visualizador.py         # Visualização gráfica
├── main_terminal.py        # Interface terminal
├── interface.py            # Interface gráfica
└── test_afn.py            # Testes automatizados
\end{lstlisting}

\subsection{Comandos Úteis}

\begin{infobox}{Referência Rápida}
\begin{lstlisting}[style=bashstyle]
# Executar versao terminal
python main_terminal.py

# Executar interface grafica
python interface.py

# Executar todos os testes
python -m pytest test_afn.py -v

# Executar testes especificos
python -m pytest test_afn.py::TestConversorKleene -v

# Instalar dependencias
pip install matplotlib
\end{lstlisting}
\end{infobox}

\subsection{Exemplos de Expressões Regulares}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\rowcolor{pastelblue!40}
\textbf{Expressão} & \textbf{Linguagem Aceita} \\
\hline
$a$ & Apenas "a" \\
\hline
$a|b$ & "a" ou "b" \\
\hline
$ab$ & "ab" \\
\hline
$a^*$ & $\varepsilon$, "a", "aa", "aaa", ... \\
\hline
$(a|b)^*$ & Qualquer combinação de 'a' e 'b' \\
\hline
$(0|1)^*$ & Cadeias binárias \\
\hline
$a^*b^*$ & Zero ou mais 'a' seguidos de zero ou mais 'b' \\
\hline
$(ab)^*$ & $\varepsilon$, "ab", "abab", "ababab", ... \\
\hline
\end{tabular}
\caption{Exemplos de expressões regulares suportadas}
\end{table}

\end{document}
